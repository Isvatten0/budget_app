{"ast":null,"code":"import { supabase } from './supabase';\nclass AchievementService {\n  // Check and award achievements based on user actions\n  async checkAchievements(userId, action, data) {\n    const newAchievements = [];\n    try {\n      // Get user's current stats\n      const {\n        data: userStats\n      } = await supabase.from('user_stats').select('*').eq('user_id', userId).single();\n\n      // Get user's existing achievements\n      const {\n        data: existingAchievements\n      } = await supabase.from('user_achievements').select('achievement_id').eq('user_id', userId);\n      const earnedAchievementIds = (existingAchievements === null || existingAchievements === void 0 ? void 0 : existingAchievements.map(ua => ua.achievement_id)) || [];\n\n      // Get all available achievements\n      const {\n        data: allAchievements\n      } = await supabase.from('achievements').select('*');\n      if (!allAchievements) return newAchievements;\n\n      // Check each achievement\n      for (const achievement of allAchievements) {\n        if (earnedAchievementIds.includes(achievement.id)) continue;\n        const isEarned = await this.checkAchievementRequirement(userId, achievement, userStats, action, data);\n        if (isEarned) {\n          // Award the achievement\n          await this.awardAchievement(userId, achievement.id);\n          newAchievements.push(achievement);\n        }\n      }\n      return newAchievements;\n    } catch (error) {\n      console.error('Error checking achievements:', error);\n      return newAchievements;\n    }\n  }\n  async checkAchievementRequirement(userId, achievement, userStats, action, data) {\n    const {\n      type,\n      value\n    } = achievement.requirements;\n    switch (type) {\n      case 'balance_threshold':\n        return await this.checkBalanceThreshold(userId, value);\n      case 'goals_created':\n        return await this.checkGoalsCreated(userId, value);\n      case 'goals_completed':\n        return await this.checkGoalsCompleted(userId, value);\n      case 'bills_added':\n        return await this.checkBillsAdded(userId, value);\n      case 'income_entries':\n        return await this.checkIncomeEntries(userId, value);\n      case 'app_usage_streak':\n        return await this.checkAppUsageStreak(userId, value);\n      case 'budget_streak':\n        return await this.checkBudgetStreak(userId, value);\n      case 'income_log_streak':\n        return await this.checkIncomeLogStreak(userId, value);\n      case 'bills_on_time_streak':\n        return await this.checkBillsOnTimeStreak(userId, value);\n      default:\n        return false;\n    }\n  }\n  async checkBalanceThreshold(userId, threshold) {\n    var _balances$;\n    const {\n      data: balances\n    } = await supabase.from('bank_balances').select('amount').eq('user_id', userId).order('timestamp', {\n      ascending: false\n    }).limit(1);\n    return (balances === null || balances === void 0 ? void 0 : (_balances$ = balances[0]) === null || _balances$ === void 0 ? void 0 : _balances$.amount) >= threshold || false;\n  }\n  async checkGoalsCreated(userId, count) {\n    const {\n      count: goalsCount\n    } = await supabase.from('goals').select('*', {\n      count: 'exact',\n      head: true\n    }).eq('user_id', userId);\n    return (goalsCount || 0) >= count;\n  }\n  async checkGoalsCompleted(userId, count) {\n    const {\n      data: goals\n    } = await supabase.from('goals').select('current_amount, target_amount').eq('user_id', userId);\n    const completedGoals = (goals === null || goals === void 0 ? void 0 : goals.filter(goal => goal.current_amount >= goal.target_amount).length) || 0;\n    return completedGoals >= count;\n  }\n  async checkBillsAdded(userId, count) {\n    const {\n      count: billsCount\n    } = await supabase.from('recurring_expenses').select('*', {\n      count: 'exact',\n      head: true\n    }).eq('user_id', userId);\n    return (billsCount || 0) >= count;\n  }\n  async checkIncomeEntries(userId, count) {\n    const {\n      count: incomeCount\n    } = await supabase.from('income_entries').select('*', {\n      count: 'exact',\n      head: true\n    }).eq('user_id', userId);\n    return (incomeCount || 0) >= count;\n  }\n  async checkAppUsageStreak(userId, days) {\n    // This would need to be implemented with daily login tracking\n    // For now, return false\n    return false;\n  }\n  async checkBudgetStreak(userId, days) {\n    // This would need to be implemented with daily budget compliance tracking\n    // For now, return false\n    return false;\n  }\n  async checkIncomeLogStreak(userId, days) {\n    // This would need to be implemented with daily income logging tracking\n    // For now, return false\n    return false;\n  }\n  async checkBillsOnTimeStreak(userId, days) {\n    // This would need to be implemented with bill payment tracking\n    // For now, return false\n    return false;\n  }\n  async awardAchievement(userId, achievementId) {\n    await supabase.from('user_achievements').insert({\n      user_id: userId,\n      achievement_id: achievementId\n    });\n  }\n\n  // Get user's achievements\n  async getUserAchievements(userId) {\n    const {\n      data\n    } = await supabase.from('user_achievements').select(`\n        *,\n        achievement:achievements(*)\n      `).eq('user_id', userId).order('earned_at', {\n      ascending: false\n    });\n    return data || [];\n  }\n\n  // Get user's stats\n  async getUserStats(userId) {\n    const {\n      data\n    } = await supabase.from('user_stats').select('*').eq('user_id', userId).single();\n    return data;\n  }\n\n  // Get all available achievements\n  async getAllAchievements() {\n    const {\n      data\n    } = await supabase.from('achievements').select('*').order('points', {\n      ascending: true\n    });\n    return data || [];\n  }\n\n  // Get user's profile badges\n  async getUserProfileBadges(userId) {\n    const {\n      data\n    } = await supabase.from('user_profile_badges').select(`\n        *,\n        badge:profile_badges(*)\n      `).eq('user_id', userId).order('earned_at', {\n      ascending: false\n    });\n    return data || [];\n  }\n\n  // Get all available profile badges\n  async getAllProfileBadges() {\n    const {\n      data\n    } = await supabase.from('profile_badges').select('*').order('rarity', {\n      ascending: true\n    });\n    return data || [];\n  }\n\n  // Equip/unequip a profile badge\n  async toggleBadgeEquipped(userId, badgeId, isEquipped) {\n    await supabase.from('user_profile_badges').update({\n      is_equipped: isEquipped\n    }).eq('user_id', userId).eq('badge_id', badgeId);\n  }\n}\nexport const achievementService = new AchievementService();","map":{"version":3,"names":["supabase","AchievementService","checkAchievements","userId","action","data","newAchievements","userStats","from","select","eq","single","existingAchievements","earnedAchievementIds","map","ua","achievement_id","allAchievements","achievement","includes","id","isEarned","checkAchievementRequirement","awardAchievement","push","error","console","type","value","requirements","checkBalanceThreshold","checkGoalsCreated","checkGoalsCompleted","checkBillsAdded","checkIncomeEntries","checkAppUsageStreak","checkBudgetStreak","checkIncomeLogStreak","checkBillsOnTimeStreak","threshold","_balances$","balances","order","ascending","limit","amount","count","goalsCount","head","goals","completedGoals","filter","goal","current_amount","target_amount","length","billsCount","incomeCount","days","achievementId","insert","user_id","getUserAchievements","getUserStats","getAllAchievements","getUserProfileBadges","getAllProfileBadges","toggleBadgeEquipped","badgeId","isEquipped","update","is_equipped","achievementService"],"sources":["/workspace/src/lib/achievement-service.ts"],"sourcesContent":["import { supabase } from './supabase'\n\nexport interface Achievement {\n  id: string\n  name: string\n  description: string\n  icon: string\n  category: 'savings' | 'budgeting' | 'goals' | 'streaks' | 'milestones'\n  rarity: 'common' | 'rare' | 'epic' | 'legendary'\n  points: number\n  requirements: any\n  created_at: string\n}\n\nexport interface UserAchievement {\n  id: string\n  user_id: string\n  achievement_id: string\n  earned_at: string\n  progress?: any\n  achievement?: Achievement\n}\n\nexport interface UserStats {\n  id: string\n  user_id: string\n  total_balance_high: number\n  total_saved: number\n  goals_completed: number\n  bills_paid_on_time: number\n  days_streak: number\n  longest_streak: number\n  last_activity_date: string\n  created_at: string\n  updated_at: string\n}\n\nexport interface ProfileBadge {\n  id: string\n  name: string\n  description: string\n  icon: string\n  color: string\n  rarity: string\n  created_at: string\n}\n\nexport interface UserProfileBadge {\n  id: string\n  user_id: string\n  badge_id: string\n  earned_at: string\n  is_equipped: boolean\n  badge?: ProfileBadge\n}\n\nclass AchievementService {\n  // Check and award achievements based on user actions\n  async checkAchievements(userId: string, action: string, data?: any): Promise<Achievement[]> {\n    const newAchievements: Achievement[] = []\n    \n    try {\n      // Get user's current stats\n      const { data: userStats } = await supabase\n        .from('user_stats')\n        .select('*')\n        .eq('user_id', userId)\n        .single()\n\n      // Get user's existing achievements\n      const { data: existingAchievements } = await supabase\n        .from('user_achievements')\n        .select('achievement_id')\n        .eq('user_id', userId)\n\n      const earnedAchievementIds = existingAchievements?.map(ua => ua.achievement_id) || []\n\n      // Get all available achievements\n      const { data: allAchievements } = await supabase\n        .from('achievements')\n        .select('*')\n\n      if (!allAchievements) return newAchievements\n\n      // Check each achievement\n      for (const achievement of allAchievements) {\n        if (earnedAchievementIds.includes(achievement.id)) continue\n\n        const isEarned = await this.checkAchievementRequirement(userId, achievement, userStats, action, data)\n        \n        if (isEarned) {\n          // Award the achievement\n          await this.awardAchievement(userId, achievement.id)\n          newAchievements.push(achievement)\n        }\n      }\n\n      return newAchievements\n    } catch (error) {\n      console.error('Error checking achievements:', error)\n      return newAchievements\n    }\n  }\n\n  private async checkAchievementRequirement(\n    userId: string, \n    achievement: Achievement, \n    userStats: UserStats | null,\n    action: string,\n    data?: any\n  ): Promise<boolean> {\n    const { type, value } = achievement.requirements\n\n    switch (type) {\n      case 'balance_threshold':\n        return await this.checkBalanceThreshold(userId, value)\n      \n      case 'goals_created':\n        return await this.checkGoalsCreated(userId, value)\n      \n      case 'goals_completed':\n        return await this.checkGoalsCompleted(userId, value)\n      \n      case 'bills_added':\n        return await this.checkBillsAdded(userId, value)\n      \n      case 'income_entries':\n        return await this.checkIncomeEntries(userId, value)\n      \n      case 'app_usage_streak':\n        return await this.checkAppUsageStreak(userId, value)\n      \n      case 'budget_streak':\n        return await this.checkBudgetStreak(userId, value)\n      \n      case 'income_log_streak':\n        return await this.checkIncomeLogStreak(userId, value)\n      \n      case 'bills_on_time_streak':\n        return await this.checkBillsOnTimeStreak(userId, value)\n      \n      default:\n        return false\n    }\n  }\n\n  private async checkBalanceThreshold(userId: string, threshold: number): Promise<boolean> {\n    const { data: balances } = await supabase\n      .from('bank_balances')\n      .select('amount')\n      .eq('user_id', userId)\n      .order('timestamp', { ascending: false })\n      .limit(1)\n\n    return balances?.[0]?.amount >= threshold || false\n  }\n\n  private async checkGoalsCreated(userId: string, count: number): Promise<boolean> {\n    const { count: goalsCount } = await supabase\n      .from('goals')\n      .select('*', { count: 'exact', head: true })\n      .eq('user_id', userId)\n\n    return (goalsCount || 0) >= count\n  }\n\n  private async checkGoalsCompleted(userId: string, count: number): Promise<boolean> {\n    const { data: goals } = await supabase\n      .from('goals')\n      .select('current_amount, target_amount')\n      .eq('user_id', userId)\n\n    const completedGoals = goals?.filter(goal => goal.current_amount >= goal.target_amount).length || 0\n    return completedGoals >= count\n  }\n\n  private async checkBillsAdded(userId: string, count: number): Promise<boolean> {\n    const { count: billsCount } = await supabase\n      .from('recurring_expenses')\n      .select('*', { count: 'exact', head: true })\n      .eq('user_id', userId)\n\n    return (billsCount || 0) >= count\n  }\n\n  private async checkIncomeEntries(userId: string, count: number): Promise<boolean> {\n    const { count: incomeCount } = await supabase\n      .from('income_entries')\n      .select('*', { count: 'exact', head: true })\n      .eq('user_id', userId)\n\n    return (incomeCount || 0) >= count\n  }\n\n  private async checkAppUsageStreak(userId: string, days: number): Promise<boolean> {\n    // This would need to be implemented with daily login tracking\n    // For now, return false\n    return false\n  }\n\n  private async checkBudgetStreak(userId: string, days: number): Promise<boolean> {\n    // This would need to be implemented with daily budget compliance tracking\n    // For now, return false\n    return false\n  }\n\n  private async checkIncomeLogStreak(userId: string, days: number): Promise<boolean> {\n    // This would need to be implemented with daily income logging tracking\n    // For now, return false\n    return false\n  }\n\n  private async checkBillsOnTimeStreak(userId: string, days: number): Promise<boolean> {\n    // This would need to be implemented with bill payment tracking\n    // For now, return false\n    return false\n  }\n\n  private async awardAchievement(userId: string, achievementId: string): Promise<void> {\n    await supabase\n      .from('user_achievements')\n      .insert({\n        user_id: userId,\n        achievement_id: achievementId\n      })\n  }\n\n  // Get user's achievements\n  async getUserAchievements(userId: string): Promise<UserAchievement[]> {\n    const { data } = await supabase\n      .from('user_achievements')\n      .select(`\n        *,\n        achievement:achievements(*)\n      `)\n      .eq('user_id', userId)\n      .order('earned_at', { ascending: false })\n\n    return data || []\n  }\n\n  // Get user's stats\n  async getUserStats(userId: string): Promise<UserStats | null> {\n    const { data } = await supabase\n      .from('user_stats')\n      .select('*')\n      .eq('user_id', userId)\n      .single()\n\n    return data\n  }\n\n  // Get all available achievements\n  async getAllAchievements(): Promise<Achievement[]> {\n    const { data } = await supabase\n      .from('achievements')\n      .select('*')\n      .order('points', { ascending: true })\n\n    return data || []\n  }\n\n  // Get user's profile badges\n  async getUserProfileBadges(userId: string): Promise<UserProfileBadge[]> {\n    const { data } = await supabase\n      .from('user_profile_badges')\n      .select(`\n        *,\n        badge:profile_badges(*)\n      `)\n      .eq('user_id', userId)\n      .order('earned_at', { ascending: false })\n\n    return data || []\n  }\n\n  // Get all available profile badges\n  async getAllProfileBadges(): Promise<ProfileBadge[]> {\n    const { data } = await supabase\n      .from('profile_badges')\n      .select('*')\n      .order('rarity', { ascending: true })\n\n    return data || []\n  }\n\n  // Equip/unequip a profile badge\n  async toggleBadgeEquipped(userId: string, badgeId: string, isEquipped: boolean): Promise<void> {\n    await supabase\n      .from('user_profile_badges')\n      .update({ is_equipped: isEquipped })\n      .eq('user_id', userId)\n      .eq('badge_id', badgeId)\n  }\n}\n\nexport const achievementService = new AchievementService()"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}